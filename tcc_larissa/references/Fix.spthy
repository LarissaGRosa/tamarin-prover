//run: tamarin-prover --heuristic=o --oraclename=oracle.py --stop-on-trace=SEQDFS --prove
//
//==============================================================================
//summary of summaries:
//
//analyzed: Fix.spthy
//
//chatty (all-traces): verified (106 steps)
//  readA (all-traces): verified (25 steps)
//  lookA (all-traces): verified (62 steps)
//  sendcashNoAtt (exists-trace): verified (11 steps)
//  cashforvoucherFix (all-traces): verified (4 steps)
//  cashforcontainerFix (all-traces): verified (2 steps)
//  cashforcontainerCustFix (all-traces): verified (79 steps)
//  cashforpurchaseFix (all-traces): verified (4 steps)
//  cashforpurchaseCustFix (all-traces): verified (3 steps)
//
//==============================================================================
//tamarin-prover --heuristic=o --oraclename=oracle.py --stop-on-trace=SEQDFS    17.07s user 10.24s system 467% cpu 5.835 total

theory Fix  

begin

functions: receipt/1, 
object/1,
look/1,
get/1

equations: get(object(a))=a,
           look(receipt(a))=a

//RULES FOR VENDING MACHINE 
rule Purchase:
    [Fr(~cont_i), Fr(~receipt_i),!Reg($Cu,appid)]
    --[Type($Cu, 'customer'),
    Purchase($V,$Cu,~cont_i), Receipt_i($Cu,~receipt_i)]->
    [ 
    Out_O($V,$Cu,object(~cont_i)),
    Out_I($V, $Cu,<appid,~receipt_i>),
    Info(<appid,~cont_i,~receipt_i>)
    ]

rule Cash:
    [In_O($Cu, $V, object(cont_i)),
    In_I($Cu,$V,<appid,receipt_i>),
    Info(<appid,cont_i,receipt_i>)]
    --[GetCont($V,$Cu,cont_i),Cash($V, appid, cont_i, receipt_i),
    Type($Cu, 'customer'),Type($V, 'vending')]->
    []

//RULES FOR THE CUSTOMER
rule RegApp:
    [Fr(~appid)]
    --[Type($Cu, 'customer'), Regi($Cu,~appid)]->
    [!Reg($Cu,~appid)]

rule Return:
    [In_O($S,$Cu,object(cont_i)),
     In_I($S, $Cu, <appid, receipt_i>)]
    --[Type($Cu, 'customer'), Type($V, 'vending'), Test($Cu)]->
    [Out_O($Cu,$V,object(cont_i)), Out_I($Cu,$V,<appid,receipt_i>)]

//RULES FOR CHANNELS
rule ChanOut_I:
   [ Out_I($A, $B, x) ]
  --[ ChanOut_I($A, $B, x), Neq($A,$B)]->
   [ !Sec_I($A, $B, x) ]

rule ChanIn_I:
   [ !Sec_I($A, $B, x) ]
  --[ ChanIn_I($A, $B, x), Neq($A,$B)]->
   [ In_I($A, $B, x)]

rule ChanIn_O:
   [ Pos($A, $B, x) ]
  --[ ChanIn_O($A, $B, x), Neq($A,$B)]->
   [ In_O($A, $B, x) ]

rule ChanOut_OO:
    let x=object(y)
    in
   [ Out_O($A, $B, x) ]
  --[ ChanIn_O($A, $B, x), Neq($A,$B) ]->
   [ Pos($A, $B, x) , Look($B,y)]

rule ChanOut_OP:
    let x=receipt(y)
    in
   [ Out_O($A, $B, x) ]
  --[ ChanIn_O($A, $B, x), Neq($A,$B), NoType($B,'vending')]->
   [ Pos($A, $B, x) , Read($B,y)]

//RULES FOR HUMAN KNOWLEDGE
rule Receive_HK:
    [ GotInfo($H, x) ]
  	--[Once($H,x)]-> 
    [ !HK($H, x) ]

rule Look:
    [Look($A, x)]
    --[Human($A)]->
    [GotInfo($A,x)]

rule Read:
    [Read($A, x)]
    --[Human($A)]->
    [GotInfo($A,x)]

//Chatty
rule Chatty [color=#FF0000]:
   [ !HK($H,  x)]
  --[ Chatty($H,  x)]->
   [ Out(x) ]


//Cocky give/hand 
rule Cocky [color=#FF0000]:
    [ Pos($A,$B, x) ]
  --[  Cocky($B,x), Neq($A,$B), Neq($A,$C), Neq($B,$C), Human($B), Human($C),Once(x,x)]->
   [ In_OA($B,$C,x) ]


//Cocky get 
rule CockyGet:
    [ Out_OA($A, $B, x) ]
  --[ Neq($A,$B), Human($A)]->
   [ Out_O($A,$B, x) ]

//Forger
rule Print [color=#FF0000]:
let y=receipt(x)
in
[In(x)]
--[PrintA(x),Human($Att)]->
[PosDA($Att,y)]

rule Build [color=#FF0000]:
let y=object(x)
in
[In(x)]
--[BuildA(x),Human($Att)]->
[PosDA($Att,y)]

// Rules for dealing with objects and receipts 
rule GiveA:
[PosUA($Att,x)]
--[Human($Att)]->
[Out_OA($Att,$B,x)]

rule GetA:
[In_OA($A,$Att,x)]
--[Human($Att)]->
[PosDA($Att,x)]

rule LookA:
let x=object(y)
in
[PosDA($Att,x)]
--[LookA(y),Human($Att) ]->
[Out(y), PosUA($Att,x)]

rule ReadA:
let x=receipt(y)
in
[PosDA($Att,x)]
--[ReadA(y),Human($Att)]->
[Out(y), PosUA($Att,x)]

//RESTRICTIONS

restriction inequality:
"
    All x #i. Neq(x,x) @#i ==> F 
"

restriction type_distinct:
  "(All x t1 t2 #i #j. (Type(x,t1)@i & Type(x,t2)@j) ==> (t1 = t2))"

  
restriction once:
"All x y #i #j. Once(x,y)@i & Once(x,y)@j ==> #i=#j"

restriction human:
"All x #i. Human(x)@i ==> (Ex #j. Type(x, 'customer')@j & j < i) | 
(Ex #j. Type(x,'cashier')@j & j < i)"

restriction notype:
"All x y #i. NoType(x, y)@i ==> not(Ex #j. Type(x,y)@j)"

//LEMMAS 
lemma chatty[sources]:
"All h x #i. Chatty(h,x)@i ==>
(Ex #j. KU(x)@j & j<i) | 
(Ex s c #j. Purchase(s,c,x)@j & j<i) | 
(Ex s #j. Receipt_i(s,x)@j & j<i) " 

lemma readA[sources]:
"All x #i. ReadA(x)@i ==>
(Ex #j. KU(x)@j & j<i) | 
(Ex s #j. Receipt_i(s,x)@j & j<i) " 

lemma lookA[sources]:
"All  x #i. LookA(x)@i ==>
(Ex #j. KU(x)@j & j<i) | 
(Ex h c #j. Purchase(h,c,x)@j & j<i) | 
(Ex s #j. Receipt_i(s,x)@j & j<i) " 

//Sanity
lemma sendcashNoAtt:
exists-trace "Ex  a b m n #i. Cash(a,b,m,n)@i & 
not (Ex  x #k. PrintA(x)@k) & 
not (Ex  x #k. BuildA(x)@k) & 
not (Ex h x #k. Chatty(h,x)@k) & 
not (Ex h x #k. Cocky(h,x)@k) 
"

//Security
lemma cashforvoucherFix:
"All v appid cont receipt #i. Cash(v,appid,cont,receipt)@i 
==>
(Ex s #j. Receipt_i(s,receipt)@j & j<i & 
not(Ex a2 b2 m2 #i2. Cash(a2,b2,m2,receipt)@i2 & not(#i=#i2)))"

lemma cashforcontainerFix:
"All v appid cont receipt #i. Cash(v,appid,cont,receipt)@i 
==>
 Ex a1 b1  . 
 GetCont(a1,b1,cont)@i  &
 (not(Ex a2 b2 receipt2 #i2. Cash(a2,b2,cont,receipt2)@i2 & not(#i=#i2)) |
 Ex a3 b3 #j2. GetCont(a3,b3,cont)@j2 & not(#i=#j2))"

lemma cashforcontainerCustFix:
"All v appid cont receipt #i. Cash(v,appid,cont,receipt)@i 
==>
 Ex #k v cu. 
 GetCont(v,cu,cont)@i  & Regi(cu,appid)@k & 
 (not(Ex v1 r2 #i2. Cash(v1,cu,cont,r2)@i2 & not(#i=#i2)) |
 Ex v1 #j2. GetCont(v1,cu,cont)@j2 & not(#i=#j2))"

lemma cashforpurchaseFix:
"All v appid cont receipt #i. Cash(v,appid,cont,receipt)@i 
==>
 Ex s cu #j . 
 Purchase(s,cu,cont)@j & j<i  &
 (not(Ex a2 b2 receipt2 #i2. Cash(a2,b2,cont,receipt2)@i2 & not(#i=#i2)) |
 Ex s1 cu1 #j2. Purchase(s1,cu1,cont)@j2 & not(#j=#j2))"

lemma cashforpurchaseCustFix:
"All v appid cont receipt #i. Cash(v,appid,cont,receipt)@i 
==>
 Ex s cu #j #k. 
 Purchase(s,cu,cont)@j & j<i & Regi(cu,appid)@k &
 (not(Ex v1 r2 #i2. Cash(v1,cu,cont,r2)@i2 & not(#i=#i2)) |
 Ex s1 #j2. Purchase(s1,cu,cont)@j2 & not(#j=#j2))"


end


