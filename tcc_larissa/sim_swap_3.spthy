/* CONSIDERA QUE O ATACANTE NÃO TEM ACESSO AS RESPOSTAS DAS QUESTÕES A NÃO SER QUE ELE FAÇA UM ATAQUE
AOS DADOS, O OPERADOR PODE NÃO SER CONFIÁVEL MAS EXISTEM CONTATOS DE CONFIANÇA --> A REDE QUE SEGUE A TROCA DE CHIP */
theory sim_swap_3
begin


functions: permission/2 [private], question/2, answers/3[private], correctAnswer/1 [private], getSwapCode/1

equations:
    answers(T, K, correctAnswer(question(T, K))) = permission(T, K)



rule InitUserOnNetwork:
    
    [ Fr(~iccid), Fr(~imsKi), Fr(~userId), Fr(~initialUserName), Fr(~initialUserPhoneNumber), Fr(~userSecureContact) ]
    
    --[ InitUser($U, ~userId) ]->
    
    [ !UserAccount($U, ~userId, ~initialUserName, ~initialUserPhoneNumber, ~userSecureContact), 
      !IMSI('PAIS', $U, ~userId, ~imsKi),
      !UserICCID(~iccid, ~userId),
      Out(~initialUserName), Out(~initialUserPhoneNumber)
    ]

rule InitOperatorOnNetwork:
   
    [Fr(~opId)] 

    --[InitOperator($O, ~opId)]-> 
    
    [!Operator($O, ~opId, 'REDE')]


rule InitSimSwapWithOperator:
    
    [!Operator(O, opId, 'REDE'),  In(initialUserPhoneNumber),  Fr(~seedK)]

    --[InitSimSwap(initialUserPhoneNumber, ~seedK)]->

    [
        SimSwapINIT(~seedK, opId, initialUserPhoneNumber),
        Out(question(initialUserPhoneNumber, ~seedK)),
        Out(~seedK)
    ]



rule AnswerSimSwapToOperator:
   
    let 
        a = answers(initialUserPhoneNumber, seedK, correctAnswer(question(initialUserPhoneNumber, seedK)))
    in
    [ SimSwapINIT(seedK, opId, initialUserPhoneNumber), In(question(initialUserPhoneNumber, seedK))]
    --[AnswerSimSwap(initialUserPhoneNumber, seedK)]->
    [
        SimSwapANSWER(a, opId, initialUserPhoneNumber, seedK),
       
    ]


rule SendMessageToContactWithOperator:
    
    [SimSwapANSWER(permission(initialUserPhoneNumber, seedK), opId, initialUserPhoneNumber, seedK), !UserAccount(U, userId, initialUserName, initialUserPhoneNumber, userSecureContact)]
    --[SendMessageSimSwap(initialUserPhoneNumber, userSecureContact)]->
    [SimSwapMessageCONTACT(getSwapCode(initialUserPhoneNumber), userSecureContact, seedK)]

rule UserGetsCodeWithContactAndGeneratesNewSim:
    [SimSwapMessageCONTACT(getSwapCode(initialUserPhoneNumber), userSecureContact, seedK), Fr(~newICCID), !UserAccount(U, userId, initialUserName, initialUserPhoneNumber, userSecureContact)]
    --[UserGetsNewSim(initialUserPhoneNumber)]->
    [FinishSwap(getSwapCode(initialUserPhoneNumber), ~newICCID, userId, initialUserPhoneNumber, seedK)]

rule FinishSimSwapOnNetwork:
    [FinishSwap(getSwapCode(initialUserPhoneNumber), newICCID, userId, initialUserPhoneNumber, seedK)]
    --[FinishSimSwap(initialUserPhoneNumber, seedK)]->
    [ !UserICCID(newICCID, userId)]

rule SecretQuestionAttacked[colour=#BE2444]:
   
    let 
        c = answers(initialUserPhoneNumber, seedK, correctAnswer(question(initialUserPhoneNumber, seedK)))
    in
    [!UserAccount(R, userId, initialUserName, initialUserPhoneNumber, userSecureContact), In(seedK)]
    --[QuestionAttack(initialUserPhoneNumber, seedK)]->
    [Out(c)]

rule AttackerAnswersQuestion[colour=#C40233]:
    let 
      c = answers(initialUserPhoneNumber, seedK, correctAnswer(question(initialUserPhoneNumber, seedK)))
    in
   
    [ In(c), !Operator(O, opId, 'REDE'), In(initialUserPhoneNumber), In(seedK) ]
    --[ AttackerAnswers(initialUserPhoneNumber, seedK) ]->
    [SimSwapANSWER(permission(initialUserPhoneNumber, seedK), opId, initialUserPhoneNumber, seedK) ]

rule AttackerHelperOperator[colour=#FF6600]:
  
    [!Operator(O, opId, 'REDE')] 

    --[CorruptedOperator(O, opId)]-> 
    
    [OperatorC(O, opId)]

rule InitDishonestOperatorSimSwap[colour=#FDBE87]:
  [OperatorC(O, opId), In(initialUserPhoneNumber),  Fr(~seedK), Fr(~newICCID)]
  --[InitCorruptedSimSwap(initialUserPhoneNumber, ~seedK)]->
  [
    FinishAnswer(~newICCID, initialUserPhoneNumber, ~seedK)
  ]


lemma Sim_swap_finish_honest:
  " /* Para cada troca de chip finalizada no sistema para um número de telefone e uma seed K */
  ( All phoneNumber seedK #i.  FinishSimSwap(phoneNumber, seedK) @ #i
      ==>
        /* tem um usuário que respondeu a requisição */
      ( (
        Ex #j. AnswerSimSwap(phoneNumber, seedK) @ j 
        & j < i
        )
      )
  )
  "

lemma Sim_swap_finish_honest_or_attack:
  " /* Para cada troca de chip finalizada no sistema para um número de telefone e uma seed K */
    ( All phoneNumber seedK #i.  FinishSimSwap(phoneNumber, seedK) @ #i
       ==>
         /* tem um usuário que respondeu a requisição */
       ( (
          Ex #j. AnswerSimSwap(phoneNumber, seedK) @ j 
          & j < i
         )
         /* ou o adversário fez um ataque as perguntas de segurança */
          | (Ex #r. AttackerAnswers(phoneNumber, seedK) @ r &  r < i)
       )
    )
  "

lemma Sim_swap_finish_honest_or_attack_or_operator:
  " /* Para cada troca de chip finalizada no sistema para um número de telefone e uma seed K */
    ( All phoneNumber seedK #i.  FinishSimSwap(phoneNumber, seedK) @ #i
       ==>
         /* tem um usuário que respondeu a requisição */
       ( (
          Ex #j. AnswerSimSwap(phoneNumber, seedK) @ j 
          & j < i
         )
         /* ou o adversário fez um ataque as perguntas de segurança */
          | (Ex #r. AttackerAnswers(phoneNumber, seedK) @ r &  r < i)
          | (Ex #k. InitCorruptedSimSwap(phoneNumber, seedK) @ k & k < i)
       )
    )
  "
lemma Sim_swap_secret_answer:
  " /* Não pode ser que  */
    not(
      Ex phoneNumber seedK #i #j #k.
        /* o operador aprovou a troca do sim para o número de telefone na rede */
        FinishSimSwap(phoneNumber, seedK) @ #i
        /* e o atacante conhece a resposta de uma pergunta a partir de uma seed K qualquer*/
      & K(correctAnswer(question(phoneNumber, seedK))) @ #j
        /* E usa essa resposta para finalizar o processo de troca de chip */
      & AttackerAnswers(phoneNumber, seedK) @ #k
      & j < i
      & k < i
        /* sem que tenha realizado um ataca externo as questões */
      & not(Ex #r. QuestionAttack(phoneNumber, seedK) @ r)
    )
  "

  
end